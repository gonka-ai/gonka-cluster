---
# Firewall Configuration Role
# Configure UFW firewall rules for Gonka services

- name: Determine cluster name for all hosts
  set_fact:
    cluster_name: "{{ group_names | select('match', 'cluster[0-9]+') | first }}"

- name: Ensure DEFAULT_FORWARD_POLICY is ACCEPT
  lineinfile:
    path: /etc/default/ufw
    regexp: '^#?DEFAULT_FORWARD_POLICY=.*'
    line: 'DEFAULT_FORWARD_POLICY="ACCEPT"'
    insertafter: EOF
    create: true
  become: true

- name: Enable IPv4 forwarding persistently
  sysctl:
    name: net.ipv4.ip_forward
    value: '1'
    state: present
    sysctl_file: /etc/sysctl.d/99-gonka.conf
  become: true

- name: Ensure UFW NAT MASQUERADE for Docker subnets
  blockinfile:
    path: /etc/ufw/before.rules
    marker: "# {mark} ANSIBLE DOCKER NAT"
    insertbefore: '^\*filter'
    create: true
    block: |
      # NAT table rules (Docker egress)
      *nat
      :POSTROUTING ACCEPT [0:0]
      
      # Forward traffic from Docker containers to the public interface
      -A POSTROUTING -s 172.16.0.0/12 -j MASQUERADE
      
      COMMIT
  become: true

- name: Set UFW default incoming policy to deny
  ufw:
    direction: incoming
    policy: deny
  become: true

- name: Set UFW default outgoing policy to allow
  ufw:
    direction: outgoing
    policy: allow
  become: true

- name: Allow SSH access
  ufw:
    rule: allow
    port: 22
    proto: tcp
  become: true

- name: Allow HTTP/HTTPS access
  ufw:
    rule: allow
    port: "{{ item }}"
    proto: tcp
  loop:
    - 80
    - 443
  become: true

# Network node specific ports (EXCEPT Admin API)
- name: Allow network node public ports
  ufw:
    rule: allow
    port: "{{ item }}"
    proto: tcp
  loop:
    - "{{ api_port }}"      # API service (public)
    - "{{ rpc_port }}"      # Tendermint RPC (public)
    - "{{ p2p_port }}"      # P2P communication (public)
    # NOTE: Admin API (port 9200) is NOT exposed publicly for security
    # Access via SSH tunneling: ssh -L 9200:localhost:9200 user@server
  when: "inventory_hostname in groups[cluster_name + '_network_node']"
  become: true

# DAPI API ML Server Port - allow from ML nodes and network node
- name: Allow DAPI API ML server port from ML nodes and network node
  vars:
    network_node_ip: "{{ hostvars[groups[cluster_name + '_network_node'][0]]['ansible_host'] }}"
    allowed_dapi_sources: "{{ (groups[cluster_name + '_ml_nodes'] | map('extract', hostvars, 'ansible_host') | list) + [network_node_ip] }}"
  ufw:
    rule: allow
    port: "{{ dapi_ml_server_port }}"
    proto: tcp
    from_ip: "{{ item }}"
  loop: "{{ allowed_dapi_sources }}"
  when: "inventory_hostname in groups[cluster_name + '_network_node']"
  become: true

- name: Allow gRPC ML server port from ML nodes and network node
  vars:
    network_node_ip: "{{ hostvars[groups[cluster_name + '_network_node'][0]]['ansible_host'] }}"
    allowed_grpc_sources: "{{ (groups[cluster_name + '_ml_nodes'] | map('extract', hostvars, 'ansible_host') | list) + [network_node_ip] }}"
  ufw:
    rule: allow
    port: "{{ grpc_ml_server_port }}"
    proto: tcp
    from_ip: "{{ item }}"
  loop: "{{ allowed_grpc_sources }}"
  when: "inventory_hostname in groups[cluster_name + '_network_node']"
  become: true

# ML node specific ports - RESTRICTED to network node only
- name: Allow ML node inference port from network node only
  ufw:
    rule: allow
    port: "{{ inference_port }}"
    proto: tcp
    from_ip: "{{ hostvars[groups[cluster_name + '_network_node'][0]]['ansible_host'] }}"
  when: "inventory_hostname in groups[cluster_name + '_ml_nodes']"
  become: true

- name: Allow ML node management port from network node only
  ufw:
    rule: allow
    port: "{{ management_port }}"
    proto: tcp
    from_ip: "{{ hostvars[groups[cluster_name + '_network_node'][0]]['ansible_host'] }}"
  when: "inventory_hostname in groups[cluster_name + '_ml_nodes']"
  become: true

- name: Enable UFW firewall
  ufw:
    state: enabled
  become: true

- name: Reload firewall rules
  ufw:
    state: reloaded
  become: true

- name: Display firewall status
  command: ufw status
  register: firewall_status
  changed_when: false
  become: true

- name: Show firewall configuration
  debug:
    msg: "{{ firewall_status.stdout_lines }}"
